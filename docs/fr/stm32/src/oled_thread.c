#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/spi.h>
#include <zephyr/drivers/gpio.h>
#include <string.h>
#include <stdio.h>
#include "role_config.h"

/* externs depuis ascenseur_controle.c */
extern int ascenseur_get_target_floor(void);
extern bool ascenseur_is_going_up(void);
extern int ascenseur_get_current_floor(void);
/* NOUVEAU */
extern bool ascenseur_is_homing(void);

/* DeviceTree */
#define GPIOF_NODE DT_NODELABEL(gpiof)
#define GPIOA_NODE DT_NODELABEL(gpioa)
#define SPI_OLED_NODE DT_NODELABEL(oled)

/* Brochage */
#define PIN_CS    6   
#define PIN_DC    10  
#define PIN_RST   0   

#define OLED_MSG_MAX 128
K_MSGQ_DEFINE(oled_msgq, OLED_MSG_MAX, 4, 4); 

/* Config SPI */
static const struct spi_dt_spec spi_oled =
    SPI_DT_SPEC_GET(SPI_OLED_NODE,
                    SPI_WORD_SET(8) | SPI_TRANSFER_MSB | SPI_OP_MODE_MASTER);

static const struct device *gpiof, *gpioa;

static inline void cs_low(void)  { gpio_pin_set(gpiof, PIN_CS, 0); }
static inline void cs_high(void) { gpio_pin_set(gpiof, PIN_CS, 1); }

static void sh1106_write(const uint8_t *data, size_t len, bool is_cmd)
{
    gpio_pin_set(gpiof, PIN_DC, is_cmd ? 0 : 1);
    cs_low();
    struct spi_buf b = { .buf = (void*)data, .len = len };
    struct spi_buf_set tx = { .buffers = &b, .count = 1 };
    spi_write_dt(&spi_oled, &tx);
    cs_high();
}

static void sh1106_cmd(uint8_t c) { sh1106_write(&c, 1, true); }
static void sh1106_data(const uint8_t *d, size_t n) { sh1106_write(d, n, false); }

static void sh1106_hw_reset(void)
{
    gpio_pin_set(gpioa, PIN_RST, 0);
    k_msleep(10);
    gpio_pin_set(gpioa, PIN_RST, 1);
    k_msleep(100);
}

static void sh1106_set_page_col(uint8_t page, uint8_t col)
{
    uint8_t c = col + 2;
    sh1106_cmd(0xB0 | (page & 0x0F));
    sh1106_cmd(0x10 | ((c >> 4) & 0x0F));
    sh1106_cmd(0x00 | (c & 0x0F));
}

static void sh1106_fill(uint8_t pattern)
{
    uint8_t line[128];
    memset(line, pattern, sizeof(line));
    for (uint8_t p = 0; p < 8; p++) {
        sh1106_set_page_col(p, 0);
        sh1106_data(line, sizeof(line));
    }
}

static const uint8_t font5x7[][5] = {
    {0x00,0x00,0x00,0x00,0x00}, {0x00,0x00,0x5F,0x00,0x00}, {0x00,0x07,0x00,0x07,0x00}, {0x14,0x7F,0x14,0x7F,0x14},
    {0x24,0x2A,0x7F,0x2A,0x12}, {0x23,0x13,0x08,0x64,0x62}, {0x36,0x49,0x55,0x22,0x50}, {0x00,0x05,0x03,0x00,0x00},
    {0x00,0x1C,0x22,0x41,0x00}, {0x00,0x41,0x22,0x1C,0x00}, {0x14,0x08,0x3E,0x08,0x14}, {0x08,0x08,0x3E,0x08,0x08},
    {0x00,0x50,0x30,0x00,0x00}, {0x08,0x08,0x08,0x08,0x08}, {0x00,0x60,0x60,0x00,0x00}, {0x20,0x10,0x08,0x04,0x02},
    {0x3E,0x51,0x49,0x45,0x3E}, {0x00,0x42,0x7F,0x40,0x00}, {0x42,0x61,0x51,0x49,0x46}, {0x21,0x41,0x45,0x4B,0x31},
    {0x18,0x14,0x12,0x7F,0x10}, {0x27,0x45,0x45,0x45,0x39}, {0x3C,0x4A,0x49,0x49,0x30}, {0x01,0x71,0x09,0x05,0x03},
    {0x36,0x49,0x49,0x49,0x36}, {0x06,0x49,0x49,0x29,0x1E}, {0x00,0x36,0x36,0x00,0x00}, {0x00,0x56,0x36,0x00,0x00},
    {0x08,0x14,0x22,0x41,0x00}, {0x14,0x14,0x14,0x14,0x14}, {0x00,0x41,0x22,0x14,0x08}, {0x02,0x01,0x51,0x09,0x06},
    {0x32,0x49,0x79,0x41,0x3E}, {0x7E,0x11,0x11,0x11,0x7E}, {0x7F,0x49,0x49,0x49,0x36}, {0x3E,0x41,0x41,0x41,0x22},
    {0x7F,0x41,0x41,0x22,0x1C}, {0x7F,0x49,0x49,0x49,0x41}, {0x7F,0x09,0x09,0x09,0x01}, {0x3E,0x41,0x49,0x49,0x7A},
    {0x7F,0x08,0x08,0x08,0x7F}, {0x00,0x41,0x7F,0x41,0x00}, {0x20,0x40,0x41,0x3F,0x01}, {0x7F,0x08,0x14,0x22,0x41},
    {0x7F,0x40,0x40,0x40,0x40}, {0x7F,0x02,0x0C,0x02,0x7F}, {0x7F,0x04,0x08,0x10,0x7F}, {0x3E,0x41,0x41,0x41,0x3E},
    {0x7F,0x09,0x09,0x09,0x06}, {0x3E,0x41,0x51,0x21,0x5E}, {0x7F,0x09,0x19,0x29,0x46}, {0x46,0x49,0x49,0x49,0x31},
    {0x01,0x01,0x7F,0x01,0x01}, {0x3F,0x40,0x40,0x40,0x3F}, {0x1F,0x20,0x40,0x20,0x1F}, {0x7F,0x20,0x18,0x20,0x7F},
    {0x63,0x14,0x08,0x14,0x63}, {0x07,0x08,0x70,0x08,0x07}, {0x61,0x51,0x49,0x45,0x43}, {0,0,0,0,0},
    {0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},
    {0x20,0x54,0x54,0x54,0x78}, {0x7F,0x48,0x44,0x44,0x38}, {0x38,0x44,0x44,0x44,0x20}, {0x38,0x44,0x44,0x48,0x7F},
    {0x38,0x54,0x54,0x54,0x18}, {0x08,0x7E,0x09,0x01,0x02}, {0x0C,0x52,0x52,0x52,0x3E}, {0x7F,0x08,0x04,0x04,0x78},
    {0x00,0x44,0x7D,0x40,0x00}, {0x20,0x40,0x44,0x3D,0x00}, {0x7F,0x10,0x28,0x44,0x00}, {0x00,0x41,0x7F,0x40,0x00},
    {0x7C,0x04,0x18,0x04,0x78}, {0x7C,0x08,0x04,0x04,0x78}, {0x38,0x44,0x44,0x44,0x38}, {0x7C,0x14,0x14,0x14,0x08},
    {0x08,0x14,0x14,0x14,0x7C}, {0x7C,0x08,0x04,0x04,0x08}, {0x48,0x54,0x54,0x54,0x20}, {0x04,0x3F,0x44,0x40,0x20},
    {0x3C,0x40,0x40,0x20,0x7C}, {0x1C,0x20,0x40,0x20,0x1C}, {0x3C,0x40,0x30,0x40,0x3C}, {0x44,0x28,0x10,0x28,0x44},
    {0x0C,0x50,0x50,0x50,0x3C}, {0x44,0x64,0x54,0x4C,0x44}, {0x04,0x0E,0x15,0x04,0x04}, {0x04,0x04,0x15,0x0E,0x04},
};

static void sh1106_draw_char(uint8_t page, uint8_t col, char c)
{
    if (c < 32 || c > 126) {
        uint8_t blank[6] = {0,0,0,0,0,0};
        sh1106_set_page_col(page, col);
        sh1106_data(blank, 6);
        return;
    }
    const uint8_t *g = font5x7[c - 32];
    sh1106_set_page_col(page, col);
    sh1106_data(g, 5);
    uint8_t sp = 0x00;
    sh1106_data(&sp, 1);
}

static void sh1106_draw_string(uint8_t page, uint8_t col, const char *s)
{
    while (*s && col <= 122) {
        sh1106_draw_char(page, col, *s++);
        col += 6;
    }
}

/* === Init === */
static void sh1106_init(void)
{
    gpiof = DEVICE_DT_GET(GPIOF_NODE);
    gpioa = DEVICE_DT_GET(GPIOA_NODE);

    if (!spi_is_ready_dt(&spi_oled) || !device_is_ready(gpiof) || !device_is_ready(gpioa)) {
        printk("âŒ OLED init: pÃ©riphÃ©riques introuvables\n");
        return;
    }

    gpio_pin_configure(gpiof, PIN_DC, GPIO_OUTPUT_INACTIVE);
    gpio_pin_configure(gpiof, PIN_CS, GPIO_OUTPUT_ACTIVE);
    gpio_pin_configure(gpioa, PIN_RST, GPIO_OUTPUT_INACTIVE);

    sh1106_hw_reset();
    sh1106_cmd(0xAE); sh1106_cmd(0xAF); /* ON */
    sh1106_fill(0x00);
}

void oled_display_text(const char *text) { sh1106_fill(0); sh1106_draw_string(3, 10, text); }
void oled_update_text(const char *text) { if (text) k_msgq_put(&oled_msgq, text, K_NO_WAIT); }

void oled_thread(void)
{

    /* ðŸ‘‡ DÃ‰SACTIVATION SI MODE SORTIE ðŸ‘‡ */
    #ifndef BOARD_ROLE_ENTRY
        while (1) k_sleep(K_FOREVER);
    #endif


    char msg[OLED_MSG_MAX];
    sh1106_init();
    
    int last_cur = -2; /* Force update */
    int last_tgt = -2;
    bool last_homing = false;
    
    while (1) {
        /* Message prioritaire (ex: "Bienvenue") */
        if (k_msgq_get(&oled_msgq, msg, K_NO_WAIT) == 0) {
            sh1106_fill(0x00);
            sh1106_draw_string(3, 10, msg);
            k_msleep(2000); /* On laisse le message un peu */
            last_cur = -2; /* Force refresh interface */
        }
        
        bool is_homing = ascenseur_is_homing();
        int cur = ascenseur_get_current_floor();
        int tgt = ascenseur_get_target_floor();
        bool moving = (tgt >= 0 && cur != tgt);

        if (is_homing) {
            if (!last_homing) {
                sh1106_fill(0x00);
                sh1106_draw_string(2, 20, "CALIBRATION...");
                sh1106_draw_string(4, 10, "Recherche RDC");
                last_homing = true;
                last_cur = -2; /* Invalider pour aprÃ¨s */
            }
        } 
        else if (cur != last_cur || tgt != last_tgt || last_homing) {
            last_homing = false;
            last_cur = cur;
            last_tgt = tgt;
            
            sh1106_fill(0x00);
            sh1106_draw_string(0, 25, "ASCENSEUR");
            
            char line[32];
            snprintf(line, sizeof(line), "Etage: %d", cur);
            sh1106_draw_string(2, 20, line);
            
            /* Affichage Cible */
            if (tgt >= 0) {
                snprintf(line, sizeof(line), "Cible: %d", tgt);
                sh1106_draw_string(4, 20, line);
                sh1106_draw_string(6, 10, "En mouvement...");
            } else {
                sh1106_draw_string(4, 20, "Cible: --");
                sh1106_draw_string(6, 10, "A l'arret");
            }
        }
        
        k_sleep(K_MSEC(200));
    }
}
K_THREAD_DEFINE(oled_thread_id, 2048, oled_thread, NULL, NULL, NULL, 12, 0, 0);