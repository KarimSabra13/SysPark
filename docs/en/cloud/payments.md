Language: English | [Français](../../fr/cloud/payments.md)

# Payments and Billing Flow

SysPark integrates online payments to enable controlled exits, billing traceability, and a clear operator workflow. Payments are validated in the Cloud and used as an authorization signal to unlock the exit sequence, while local safety and deterministic actuation remain handled on-site.

This document defines:
- how fees are computed,
- how a payment request is generated,
- how payment validation is confirmed,
- how the exit is unlocked,
- how everything is logged and audited,
- what happens in degraded modes.

---

## 1) Actors and responsibilities

### Cloud backend (Render)
- Computes the fee for a session (tariff rules, duration, discounts if applicable).
- Generates the payment request context for the user.
- Validates the payment server-side using the payment provider confirmation.
- Publishes a payment authorization event used to unlock exit.
- Persists the full audit trail (session, payment proof, timestamps, operator actions).

### Payment provider (Stripe)
- Handles the user payment UI and card processing.
- Notifies the Cloud of the final result through a server-to-server confirmation.
- Provides a reference ID and proof that the Cloud stores for audits.

### Site edge gateway (BeagleY-AI)
- Relays payment-related events between local site and cloud through MQTT (via a selective bridge).
- Keeps the lane logic consistent with the system state (display messages, flow transitions).

### Exit controller (STM32 exit role)
- Waits for a valid “payment success” authorization to proceed with exit.
- Enforces the local exit sequence (user guidance, confirmation, and final trigger for barrier opening through the execution layer).

### Execution layer (FPGA / actuator executor)
- Opens the barrier deterministically after authorization.
- Applies safety limits (timeouts, obstruction handling, safe state on fault).

---

## 2) Data objects (conceptual)

### Session
A “session” represents one vehicle parking cycle.
Typical fields:
- `session_id` (unique, generated by cloud)
- `entry_ts`, `exit_ts`
- `identity` reference (plate if available, badge UID if applicable, or fallback token)
- `status`: active, pending_payment, paid, closed, flagged

### Payment record
A payment record links to exactly one session.
Typical fields:
- `payment_id` (cloud internal)
- `provider`: stripe
- `provider_ref`: provider transaction / intent reference
- `amount`, `currency`
- `validated_ts`
- `state`: requested, pending, paid, failed, canceled

---

## 3) Fee computation rules

Fee computation happens in the Cloud because it depends on global policy.
Inputs can include:
- session duration (entry_ts to now),
- tariff table (per-hour rates, flat fees, grace period),
- penalties (lost ticket), discounts (subscriptions),
- optional constraints (maximum daily cap).

Outputs:
- amount due,
- pricing breakdown (optional),
- session updated to `pending_payment`.

---

## 4) End-to-end payment flow (exit lane)

### Trigger
- Vehicle detected at exit lane (presence sensor and/or vision capture).

### Step-by-step
1. **Identify the session**
   - Preferred: use license plate recognition to match the active session.
   - Fallbacks: RFID badge, exit PIN, or operator-assisted selection in the dashboard.

2. **Compute fee**
   - Cloud computes the due amount.
   - Cloud sets session state to `pending_payment`.

3. **Publish payment request**
   - Cloud publishes a message that carries:
     - session reference,
     - amount and currency,
     - any user message to display.

   MQTT topic:
   - `parking/payment/req`

4. **User completes payment**
   - User pays via the cloud UI linked to the session.
   - The payment provider processes the transaction.

5. **Cloud validates payment (server-side)**
   - Cloud receives a provider confirmation and validates it.
   - Cloud updates:
     - payment record → `paid`
     - session → `paid`

6. **Publish payment success authorization**
   - Cloud publishes a success message linked to the session.

   MQTT topic:
   - `parking/payment/success`

7. **Unlock exit**
   - Exit STM32 receives `payment/success` and transitions to “authorized to exit”.
   - Edge requests the executor to open the barrier.

8. **Barrier opens and session closes**
   - Executor opens safely and confirms state.
   - Cloud closes session (exit_ts, final status) and records proof.

---

## 5) MQTT messages (contract summary)

### `parking/payment/req`
Direction:
- Cloud → Local

Purpose:
- Inform the site that a payment is required and provide the billing context.

Typical fields (JSON recommended):
- `ts`, `src`
- `session_id`
- `amount`, `currency`
- optional: `label`, `reason`, `plate`, `duration`

QoS:
- 1 recommended (must arrive, duplicates acceptable)

Retain:
- No

### `parking/payment/success`
Direction:
- Cloud → Local

Purpose:
- Authorize exit based on validated payment.

Typical fields:
- `ts`, `src`
- `session_id`
- `provider_ref` (or internal proof reference)
- optional: `amount`, `currency`

QoS:
- 1 recommended

Retain:
- No

---

## 6) Security requirements

### Server-side validation only
The exit must be unlocked only after the Cloud confirms payment using provider evidence. Client-side “success” screens are not trusted.

### Replay and duplication handling
Because MQTT can deliver duplicates (QoS 1), all nodes must treat:
- repeated `payment/success` for the same session as idempotent.

### Bridge and broker hardening
- Only the payment topics and required command topics should cross the bridge.
- Anonymous publishing should be disabled in production.
- Secrets and keys remain in environment variables, never in Git.

---

## 7) Failure cases and recovery

### Payment failed / canceled
- Session remains `pending_payment`.
- Exit stays locked.
- Display shows a clear message and suggests retry or operator help.

### Cloud unreachable (internet outage)
Policy options (choose per deployment):
- Disable card payment and switch to:
  - trusted-user RFID exit,
  - exit PIN,
  - operator override with audit.
- Or enter restricted mode and route to manual operator handling.

### Provider unreachable
- Cloud cannot validate payment.
- Exit must stay locked until confirmation is received.
- Operator can override if the site policy allows.

### MQTT broker outage (public)
- Local system can keep lane safety, but payments cannot be validated remotely.
- Operate in offline policy mode with explicit operator procedures.

---

## 8) Audit trail (what must be logged)

For compliance and debugging, store:
- session lifecycle: entry_ts, payment_req_ts, payment_validated_ts, exit_ts
- amount and currency
- provider reference and validation result
- identity reference used (plate/badge/fallback)
- operator overrides (who/why/when)
- barrier execution outcome (opened, timeout, fault)

Goal:
- Every exit is explainable after the fact.
